[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to R - KNBS",
    "section": "",
    "text": "1 Introduction to R\nIn this course, you will explore the versatility of R, a powerful language for statistical computing and graphics. You will discover the benefits of using R and get started with the basics, and fain confidence with the user-friendly R Studio interface and learn fundamental R concepts. You will also dive into the Tidyverse, a collection of packages for data storage, visualisation and manipulation. This course offers a solid foundation to kickstart your journey with R!\nThis book is designed to accompany the Introduction to R training that is starting at KNBS. To complete this course, you will need to have R Studio installed on your computer.\nIf you’re running through this book solo, it is recommended to run through it in order and try out all the of the exercises as you go through. Each exercise has a Solution dropdown, which allows you to view prompts to help with the question and see the answers.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to R</span>"
    ]
  },
  {
    "objectID": "index.html#session-aims",
    "href": "index.html#session-aims",
    "title": "Introduction to R - KNBS",
    "section": "1.1 Session aims",
    "text": "1.1 Session aims\n\nnavigate the R and R Studio environment\nunderstand and use the common R functions for data manipulation\nunderstand the basics of data visualisation using the ggplot2 package\nunderstand the term tidy data and why it is important for writing efficient code",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to R</span>"
    ]
  },
  {
    "objectID": "index.html#what-is-r",
    "href": "index.html#what-is-r",
    "title": "Introduction to R - KNBS",
    "section": "1.2 What is R?",
    "text": "1.2 What is R?\nR is an open-source programming language and software environment, designed primarily for statistical computing. It has a long history - it is based on the S language, which was developed in 1976 in Bell Labs, where the UNIX operating system and the C and C++ languages were developed. The R language itself was developed in the 1990s, with the first stable version release in 2000.\nR has grown rapidly in popularity particularly in the last five years, due to the increased interest in the data science field. It is now a key tool used by analysts in governments globally.\nSome of the advantages:\n\nIt is popular - there is a large, active and rapidly growing community of R programmers, which has resulted in a plethora of resources and extensions.\nIt is powerful - the history as a statistical language means it is well suited for data analysis and manipulation.\nIt is extensible - there are a vast array of packages that can be added to extend the functionality of R, produced by statisticians and programmers around the world. These can range from obscure statistical techniques to tools for making interactive charts.\nIt’s free and open source - a large part of its popularity can be owed to its low cost, particularly relative to proprietary software such as SAS or STATA.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to R</span>"
    ]
  },
  {
    "objectID": "index.html#introducing-rstudio",
    "href": "index.html#introducing-rstudio",
    "title": "Introduction to R - KNBS",
    "section": "1.3 Introducing RStudio",
    "text": "1.3 Introducing RStudio\nRStudio is an integrated development environment (IDE) for R. You don’t have to use an IDE but it’s strongly advised as it provides a user-friendly interface to work with. RStudio has four main panels;\n\nScript Editor (top left) - used to write and save your code, which is only run when you explicitly tell RStudio to do so.\nConsole (bottom left) - all code is run through the console, even the code you write in the script editor is sent to the console to be run. It’s perfect for quickly viewing data structures and help for functions but should not be used to write code you want to save (that should be done in the script editor).\nEnvironment (top right) - all data, objects and functions that you have read in/created will appear here.\nFiles/Plots/Help (bottom right) - this pane groups a few miscellaneous areas of RStudio.\n\nFiles acts like the windows folder to navigate between files and folders.\nPlots shows any graphs that you generate.\nPackages let’s you install and manage packages currently in use.\nHelp provides information about packages or functions, including how to use them.\nViewer is essentially RStudio’s built-in browser, which can be used for web app development.\n\n\nYou may have noticed that your Script Editor is bigger than the Console or your Environment has suddenly disappeared. In RStudio, you can adjust the size of different panes by clicking and dragging the dividers between them. If you want to maximize a specific pane, such as the Script Editor, use the shortcut Ctrl + Shift + 1 (Windows/Linux) or Cmd + Shift + 1 (Mac) to focus on it. To restore the default layout, press Ctrl + Shift + 0 (Windows/Linux) or Cmd + Shift + 0 (Mac). You can also use the View menu to toggle different panes on and off, ensuring your workspace suits your needs.\nIf you find the text difficult to read or prefer a different appearance, you can customise the theme, font, and text size in RStudio. Go to Tools &gt; Global Options &gt; Appearance, where you can choose from different editor themes (e.g., light or dark mode), adjust the font type, and increase or decrease the text size for better readability. These changes can help make coding more comfortable, especially during long sessions.\n\n1.3.1 Recommended Changes\nWhile not necessary, certain changes are almost always recommended for visibility reasons. These include: - Choosing a different theme, as Textmate can be hard on the eyes. This can be done in Tools &gt; Global Options &gt; Appearance &gt; Editor theme:. - Highlight R function calls. This makes functions look a different colour than normal text, which can make reading your code much easier. This can be done in Tools &gt; Global Options &gt; Code &gt; Display &gt; Highlight R function calls. - Use Rainbow Parenthesis. This makes each pair of () in a line a different colour, which can help you catch if you’re missing one and it’s breaking your code. This can be done in Tools &gt; Global Options &gt; Code &gt; Display &gt; Use rainbow parenthesis.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to R</span>"
    ]
  },
  {
    "objectID": "index.html#basic-syntax",
    "href": "index.html#basic-syntax",
    "title": "Introduction to R - KNBS",
    "section": "1.4 Basic Syntax",
    "text": "1.4 Basic Syntax\n\n1.4.1 Exercise\n −+ 03:00 \nAs a quick exercise, try out some arithmetic in your console:\n\n25 * 15\n(45 + 3) ^ 2\n78 / 4\n\nNow open a new script (File -&gt; New File -&gt; R Script) and save it as Intro.R\n\nRepeat the above exercises. What happens when you hit enter? Try using Ctrl + Enter\n\n\n\n1.4.1. Solution\n\n\n\n25 * 15\n\n[1] 375\n\n(45 + 3) ^ 2\n\n[1] 2304\n\n78 / 4\n\n[1] 19.5\n\n\n\n\n\n\n1.4.2 The assignment operator\nR uses the assignment operator &lt;- to assign values or data frames to objects. The object name goes on the left, with the object value on the right. For example, x &lt;- 5 assigns the value 5 to the object x. You can quickly type the assignment operator in RStudio by pressing Alt + - (Windows) or Option + - (Mac).\nOther programming languages tend to use =. The equals sign is used in R but for other purposes, as you’ll find out later. Note: = will actually work for assignment in R but it is not convention.\n\n\n1.4.3 Exercise\n −+ 05:00 \n\nCreate an object x1 with a value of 14\nCreate an object x2 with a value of x1 + 7\nCheck the value of x2 by looking in the environment pane\nCreate an object x3 equal to x2 divided by 3.\n\n\n\n1.4.3. Solution\n\n\n\nx1 &lt;- 14\nx1\n\n[1] 14\n\n\n\nx2 &lt;- x1 + 7\nx2\n\n[1] 21\n\n\n\nx3 &lt;- x2 / 3\nx3\n\n[1] 7\n\n\n\n\n\n\n1.4.4 Combining using c()\nSo how do you assign more than one number to an object? Typing x &lt;- 1,2,3 will throw an error. The way to do it is to combine the values into a vector before assigning. For example, x &lt;- c(1, 2, 3).\nNote: all elements of a vector must be of the same type; either numeric, character, or logical. Vector types are important, but they aren’t interesting, which is why they aren’t covered on this course. We advise you to read about vectors in your own time.\n\n\n1.4.5 Exercise\n −+ 05:00 \n\nUse the combine function to create a vector with values 1, 2 and 3.\nWhat happens when you write 1:10 inside c()?\nWhat happens if you try to create a vector containing a number such as 2019 and the word “year”?\n\n\n\n1.4.5. Solution\n\n\n\n#1. combine c() to create vector with values 1,2,3\nx &lt;- c(1, 2, 3)\nx\n\n[1] 1 2 3\n\n#2. combine c() with 1:10\nx &lt;- c(1:10)\nx\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n#3. Incorrect code: will throw an error\nx &lt;- c(2019, year)\nx\n\n[[1]]\n[1] 2019\n\n[[2]]\nfunction (x) \n{\n    UseMethod(\"year\")\n}\n&lt;bytecode: 0x1279176a0&gt;\n&lt;environment: namespace:lubridate&gt;\n\n#3. Correct code\nx &lt;- c(2019, \"year\")\nx\n\n[1] \"2019\" \"year\"",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to R</span>"
    ]
  },
  {
    "objectID": "index.html#functions",
    "href": "index.html#functions",
    "title": "Introduction to R - KNBS",
    "section": "1.5 Functions",
    "text": "1.5 Functions\nFunctions are one of the most important aspects of any programming language. Functions are essentially just R scripts that other R users have created. You could write a whole project without using any functions, but why would we when others have done the hard work for us? To demonstrate how using functions can save us time let’s look at an example.\nImagine you had the following data for test scores of students and you wanted to find the mean score:\n\ntest_scores &lt;- c(70, 68, 56, 88, 42, 55)\n\nWe could extract each individual score from the data frame, add them together and then divide them by the number of elements:\n\n(test_scores[1] + test_scores[2] + test_scores[3] + test_scores[4] + test_scores[5] + test_scores[6]) / 6\n\n[1] 63.16667\n\n\nThis gives us the mean score of 63.2. But that’s pretty tedious, especially if our data set was of any significant size. To overcome this we can use a function called mean(). To read about a function in R type help(\"function_name\") or ?function_name in the console. By reading the help file we see that mean() requires an R object of numerical values. So we can pass our test_scores data as the argument:\n\nmean(test_scores)\n\n[1] 63.16667\n\n\nNot only does this save us time, it makes the code far more readable. While the two approaches above return the same answer, the use of the function makes our intention immediately clear. It’s important to remember it’s not just you that will be using and reading your code.\nThe values you passed to the mean function are known as arguments. Most functions require one or more arguments in order to work, and details of these can be seen by checking the help file.\nRunning ?mean shows us that the function mean has three arguments; x, trim and na.rm. You can pass these arguments to a function either by position or name. If you name the arguments in the function, R will use the values for the arguments they’ve been assigned to, e.g.:\n\nmean(x = c(1, 2, 3),\n     trim = 0,\n     na.rm = FALSE)\n\n[1] 2\n\n\nIf you don’t provide names for the arguments, R will just assign them in order, with the first value going to the first argument, etc:\n\nmean(c(1, 2, 3), #These are used for the first argument, x\n     0, #This is used for the second argument, trim\n     FALSE) #This is used for the third argument, na.rm\n\n[1] 2\n\n\nIt is good practice to use names to assign any arguments after the first one or two, to avoid confusion and mistakes!\nYou will notice that the first time we called the mean function, we didn’t have to specify values for either trim or na.rm. if you check the help file, you’ll notice that trim and na.rm have default values:\n\nmean(x, trim = 0, na.rm = FALSE)\n\nWhen arguments have default values like this, they will use these if you don’t provide an alternative. There is no default value for x, so if you don’t provide a value for x the function will return an error.\n\n1.5.1 Exercise\n −+ 05:00 \n\nLook at the help for the sum() function. What does it do?\nHow many arguments does the sum() function have? How many of these have default values?\nTry summing up the values 1 to 8 using this function.\n\n\n\n1.5.1. Solution\n\n\n\n#1. using sum() function\n?sum()\n\n#2.sum() has two arguments: a numeric value or logical vector and 'na.rm'\n# whether missing values (NA) should be removed (TRUE or FALSE)\n# by default, NA values are ignored (i.e. na.rm = TRUE)\n\n#3. summing values 1 to 8 using sum()\nsum(1:8, na.rm = TRUE)\n\n[1] 36",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to R</span>"
    ]
  },
  {
    "objectID": "index.html#packages",
    "href": "index.html#packages",
    "title": "Introduction to R - KNBS",
    "section": "1.6 Packages",
    "text": "1.6 Packages\nBeing open-source means R has an extensive community of users that are building and improving packages for others. Base R covers a lot of useful functions but there’s lots it doesn’t, that’s when we want to install packages. Each package contains a number of functions, once we install a package we have access to every one of it’s functions.\nPackages need to be both installed and loaded before they can be used. You only need to install a package the first time you use it, but you will need to load it every time you want to use it.\nStart by opening RStudio, which is an integrated development environment (IDE) for R. You don’t have to use an IDE but it’s strongly advised as it provides a user-friendly interface to work with.\nTo install a package locally, run install.packages(\"package_name\"), making sure the package name is wrapped in quotation marks. The code below will install the tidyverse package, which is actually a collection of data manipulation and presentation packages.\n\ninstall.packages(\"tidyverse\")\n\nOnce installed, you can load the packages using the library() function. Unlike installing packages, you don’t need to wrap package names in quotation marks inside a library call.\n\nlibrary(tidyverse)\n\nTo know more about a package, it is always useful to read the associated documentation. You can do this by adding a ? in front of the name of any package or function, and running this in the console\n\n?tidyverse\n\n?select",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to R</span>"
    ]
  },
  {
    "objectID": "index.html#the-tidyverse",
    "href": "index.html#the-tidyverse",
    "title": "Introduction to R - KNBS",
    "section": "1.7 The Tidyverse",
    "text": "1.7 The Tidyverse\nWhile base R has a wide range of functions for data manipulation and visualisation, most analytical code will make use of the tidyverse. This is a specific group of packages which are designed for use in the reading, processing and visualisation of data, and aim to be easy to use for beginner coders and clear to read and write. It is recommended to use the tidyverse packages wherever possible to make code consistent.\nThis training course will therefore make extensive use of tidyverse packages including dplyr, ggplot2 and tidyr.\nThe following exercise should be completed by those who are running through the course solo.\n\n1.7.1 Exercise\n\nInstall the tidyverse package in your Console (do you remember where this is?!)\nLoad the tidyverse library at the top of your Intro.R script.\n\n\n\n1.7.1. Solution\n\n\n\nlibrary(tidyverse)\n\n\n\n\n\n\n\n\n\n\n\n\nThis is a good opportunity to take a 10-minute break away from the computer to refresh your mind, stretch, and reset before continuing onto Chapter 2.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to R</span>"
    ]
  },
  {
    "objectID": "data_manipulation.html",
    "href": "data_manipulation.html",
    "title": "2  Data Manipulation",
    "section": "",
    "text": "2.1 Select\nIn this chapter, we will cover dplyr, one of the most essential packages in an R user’s toolkit. As a key part of the tidyverse, dplyr offers easy-to-use functions for manipulating data frames, which is a vital step in the data analysis process.\nTo illustrate the key functions of dplyr, we’ll be using the gapminder dataset. You can view this dataset by installing and loading the gapminder package, just as you did with tidyverse.\nThe exercises in this chapter will use an inbuilt R dataset. However, if you’d like to follow along with the examples, you’re welcome to load the gapminder dataset, although please note it will not be required for the exercises themselves.\nThere are six key dplyr functions that allow you to solve the vast majority of data-manipulation challenges;\nThese functions look similar to SQL statements and are designed to replace the need for any data manipulation in SQL.\nAll dplyr functions allow you to specify the column names without “quotations”. However, if there are spaces in the column name, you’ll need to use `back ticks`.\nSelect allows you to choose the columns that you’d like to keep from a dataset.\n?select\nLooking at the gapminder dataset, if we want to create a new dataset which only included the year, country and life expectancy, we could do this by selecting those columns:\ngapminder_life_exp &lt;- select(gapminder, year, country, lifeExp)\nThe first argument within the select command specifies use of the gapminder dataset. Following this we list the variables we want to keep.\nIt is also possible to select to exclude specific columns. This is ideal if you want to keep all columns except for one or two, and can be done by using a - minus sign in front of column names.\n#Removes the continent column but keeps all others\ngapminder_no_continent &lt;- select(gapminder, -continent)\nYou can also use the select function to reorder columns as it will select columns in the order specified.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data Manipulation</span>"
    ]
  },
  {
    "objectID": "data_manipulation.html#select",
    "href": "data_manipulation.html#select",
    "title": "2  Data Manipulation",
    "section": "",
    "text": "2.1.1 Exercise\n −+ 10:00 \n\nUsing the inbuilt dataset airquality, select to keep the columns Ozone, Temp, Month and Day.\n\n\n\n2.1.1. Solution\n\n\n\nairquality_exercise &lt;-\n  select(airquality, Ozone, Temp, Month, Day)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data Manipulation</span>"
    ]
  },
  {
    "objectID": "data_manipulation.html#pipes",
    "href": "data_manipulation.html#pipes",
    "title": "2  Data Manipulation",
    "section": "2.2 Pipes",
    "text": "2.2 Pipes\nBefore we continue, let’s visit one of the most important (and cool) operators in R… the pipe |&gt;. You may have seen the old pipe %&gt;% before. This has been replaced with a native pipe in R 4.1 onwards. It’s likely that you’ll want to use multiple functions consecutively, especially when using dplyr. Currently, we may do something like this:\n\ngapminder_new &lt;- select(gapminder, -continent)\ngapminder_new &lt;- select(gapminder_new, year, country, lifeExp)\n\nThis code is a little frustrating to write because we have to name each intermediate data frame, even though we don’t care about it. Naming things is hard, and having separate names for each step makes it difficult to read. Let’s see how we can rewrite this code using the pipe:\n\ngapminder_new &lt;- gapminder |&gt;\n select(-continent) |&gt; \n select(year, country, lifeExp)\n\nThe pipe means we can read this code as a series of statements separated by the pipe representing “and then”; e.g. take the gapminder data and then remove the continent column and then select the year, country and lifeExp columns.\nYou may notice that we don’t need to specify the data argument in each function when using |&gt;. By piping, the subsequent function recognises we want to use the result of our previous statement as our data.\nYou can quickly insert the pipe operator in RStudio by pressing Ctrl + Shift + M (Windows) or Cmd + Shift + M (Mac). This will still insert the old pipe %&gt;%. This can be changed in Tools &gt; Global Options &gt; Code &gt; Editing &gt; Use native pipe operator, |&gt;",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data Manipulation</span>"
    ]
  },
  {
    "objectID": "data_manipulation.html#grouping-and-summarising-data",
    "href": "data_manipulation.html#grouping-and-summarising-data",
    "title": "2  Data Manipulation",
    "section": "2.3 Grouping and summarising data",
    "text": "2.3 Grouping and summarising data\nWe can produce breakdowns of statistics using the group_by and summarise commands from the dplyr package:\n\ngroup_by() identifies which variables we want to produce breakdowns by.\nsummarise() is used to indicate which values we want to calculate.\n\nUsing these functions together we can produce summary statistics in a similar way to pivot tables in Excel. We can use the pipe (|&gt;) operator to chain these functions together.\nSo if we want the mean life expectancy by continent and year:\n\nmean_life_exp &lt;- gapminder |&gt;\n  group_by(year, continent) |&gt;\n  summarise(life_exp = mean(lifeExp))\n\nHere R takes the dataset, then groups it first by year and then by continent and then outputs the mean life expectancy. The mean life expentancy variable is created as a new column called life_exp. The results are saved into a new dataset called mean_life_exp.\nThere are other functions that could be used here instead of mean e.g. n, n_distinct, min, max, mean, median, var and sd.\nIf we want to add a new variable that we decide to call country_count that provides the counts by year and continent we can rerun as follows using the pipe operator:\n\nmean_life_exp &lt;- gapminder |&gt;\n  group_by(year, continent) |&gt;\n  summarise(life_exp = mean(lifeExp), country_count = n())\n\n\n2.3.1 Exercise\n −+ 10:00 \n\nUsing the pipe function, group the airquality dataset by month.\nSummarise the grouped dataset to produce an average of Ozone and Temp by month.\nAssign this to an object called airquality_summarised.\n\n\n\n2.3.1. Solution\n\n\n\nairquality_summarised &lt;- airquality |&gt;\n  group_by(Month) |&gt;\n  summarise(avg_ozone = mean(Ozone, na.rm = TRUE),\n            avg_temp = mean(Temp, na.rm = TRUE))",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data Manipulation</span>"
    ]
  },
  {
    "objectID": "data_manipulation.html#filter",
    "href": "data_manipulation.html#filter",
    "title": "2  Data Manipulation",
    "section": "2.4 Filter",
    "text": "2.4 Filter\nIf you would like to produce statistics for a subset of rows or observations, a good function to use is filter() from the dplyr package.\nLet’s first take a look at the different possible values of the continent variable. We can do that quickly using the group_by/summarise combination.\n\ngapminder |&gt;\n  group_by(continent) |&gt;\n  summarise(count = n())\n\nTo filter we just specify the data that we want to filter (gapminder) and the value that we want to filter on. In this case lets filter where continent is “Asia” and year is after 1992 then recalculate the mean life expectancy by country:\n\nmean_life_exp &lt;- gapminder |&gt; \nfilter(continent == \"Asia\" & year &gt; 1992) |&gt;\ngroup_by(country) |&gt;\nsummarise(life_exp = mean(lifeExp))\n\nR provides the standard suite of comparison operators which can be used to filter:\n\n\n\nComparison\nOperator\n\n\n\n\nGreater than\n&gt;\n\n\nGreater than or equal to\n&gt;=\n\n\nLess than\n&lt;\n\n\nLess than or equal to\n&lt;=\n\n\nEqual to\n==\n\n\nNot equal to\n!=\n\n\nAnd\n&\n\n\nOr\n|\n\n\nNot\n!\n\n\nGroup membership\n%in%\n\n\n\nThe %in% operator allows you to compare a column against a vector of values to see if it matches any one of them; this is much more convenient than comparing against each value individually.\n\n##This does work to filter the data for the three given years but is clunky to read and edit\ngapminder |&gt; \nfilter(year == 1992 | year == 1998 | year == 2002) \n\n##Using the %in% operator is simple and clean to read, and gives exactly the same result\ngapminder |&gt; \nfilter(year %in% c(1992, 1998, 2002)) \n\n\n2.4.1 Exercise\n −+ 05:00 \n\nFilter the original airquality dataset to only include data for May and June. Try to do this using the %in% function.\nCall this assignment: airquality_filter.\n\n\n\n2.4.1. Solution\n\n\n\nairquality_filter &lt;- airquality |&gt;\n  filter(Month %in% c(5, 6))",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data Manipulation</span>"
    ]
  },
  {
    "objectID": "data_manipulation.html#rename",
    "href": "data_manipulation.html#rename",
    "title": "2  Data Manipulation",
    "section": "2.5 Rename",
    "text": "2.5 Rename\nWe can rename variables using the dplyr function rename(). Let’s amend our previous code creating the mean_life_exp dataset to change the name of the “year” column to “selected_year”.\n\nmean_life_exp &lt;- gapminder |&gt; \n  filter(continent == \"Asia\" & year &gt; 1992) |&gt;\n  group_by(year, country) |&gt;\n  summarise(life_exp = mean(lifeExp)) |&gt;\n  rename(selected_year = year)\n\nWithin the rename function, the new name “selected_year” is specified on the left and the old name on the right of the equal sign.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data Manipulation</span>"
    ]
  },
  {
    "objectID": "data_manipulation.html#mutate",
    "href": "data_manipulation.html#mutate",
    "title": "2  Data Manipulation",
    "section": "2.6 Mutate",
    "text": "2.6 Mutate\nYou can create new columns and perform calculations on existing columns using the dplyr command mutate().\n\n?mutate\n\nFor example, imagine we wanted to calculate overall GDP as a new column in the gapminder dataset. We could do this by multiplying the gdpPercap and pop columns:\n\ngapminder |&gt;\n  mutate(gdp_total = gdpPercap * pop)\n\nYou can also use functions like mean() and sum() in mutate(). For example, using x / sum(x) for calculating proportions of a total and y - mean(y) for difference from the mean.\nNotice that by default, mutate calculates values on a rowwise basis; each value in the gdp_total column is made by multiplying the values in the corresponding row. This default behaviour can be changed by grouping data before mutate, e.g. this code produces a mean population column by country:\n\ngapminder |&gt;\n group_by(country) |&gt;\n mutate(mean_pop = mean(pop))\n\nYou can also combine mutate with the case_when function to perform one or more if/else conditions. Maybe we want to have coded values for each year by decade. The case_when function allows you to provide multiple instances of a statement which evaluates to TRUE/FALSE, and then a result if that condition is true (after ~). The function evaluates these statements in order, so if an earlier statement is TRUE, a later one will not be evaluated. Finally, for cases that don’t meet any of the conditions, the final TRUE value is used (this defaults to NA if not specified)\n\ngapminder |&gt;\n  mutate(\n    decade =\n      case_when(\n        year &gt;= 1950 & year &lt; 1960 ~ \"1950s\",\n        year &gt;= 1960 & year &lt; 1970 ~ \"1960s\",\n        year &gt;= 1970 & year &lt; 1980 ~ \"1970s\",\n        year &gt;= 1980 & year &lt; 1990 ~ \"1980s\",\n        year &gt;= 1990 & year &lt; 2000 ~ \"1990s\",\n        TRUE ~ \"Post-2000\"\n      )\n  )\n\nYou can download the Data Transformation Cheat Sheet (and other cheatsheets) at: https://www.rstudio.com/resources/cheatsheets/\n\n2.6.1 Exercise\n −+ 10:00 \n\nThe inbuilt trees dataset includes columns for tree girth and height in inches. Using mutate, create two new columns (Girth_cm and Height_cm) containing the equivalent values in centimetres.\nHow can you replace an existing column with a new column using mutate?\n\n\n\n2.6.1. Solution\n\n\n\n# 1. conversion is 2.54\n\ntrees_with_cm &lt;- trees |&gt;\n  mutate(Girth_cm = Girth * 2.54,\n         Height_cm = Height * 2.54)\n\n# 2. Using mutate to replace existing column\n\ntrees_with_cm &lt;- trees |&gt;\n  mutate(Girth = Girth * 2.54)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data Manipulation</span>"
    ]
  },
  {
    "objectID": "data_manipulation.html#arrange",
    "href": "data_manipulation.html#arrange",
    "title": "2  Data Manipulation",
    "section": "2.7 Arrange",
    "text": "2.7 Arrange\narrange() is used to change the order of rows. It takes a data frame as it’s first argument and a column name to sort by as it’s second. If you provide more than one column name, each additional column will be used to break ties in the values of preceding columns. By default arrange() will sort in ascending order (1-9 and A-Z). If you’d like to sort in descending order wrap the column name in desc(). Using arrange with one column sorts how you’d might expect:\n\ngapminder |&gt;\n arrange(year)\n\nSorting with multiple columns sorts within the hierarchy specified:\n\ngapminder |&gt;\n  arrange(year, desc(continent))\n\nIt’s worth noting that missing values (NA) are always sorted at the end:\n\ndf &lt;- tibble(x = c(1, 2, 3, NA))\narrange(df, x)\n\n# A tibble: 4 × 1\n      x\n  &lt;dbl&gt;\n1     1\n2     2\n3     3\n4    NA\n\narrange(df, desc(x))\n\n# A tibble: 4 × 1\n      x\n  &lt;dbl&gt;\n1     3\n2     2\n3     1\n4    NA\n\n\n\n2.7.1 Exercise\n −+ 05:00 \n\nArrange the rows of the trees dataset by increasing height and decreasing girth.\nWhat do you notice?\n\n\n\n2.7.1. Solution\n\n\n\ntrees_arranged &lt;- trees |&gt;\n  arrange(Height, desc(Girth))\n\n\n\nThis is a good opportunity to take a 45-minute to an hour lunch break away from the computer to refresh your mind, stretch, and reset before continuing onto Chapter 3.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data Manipulation</span>"
    ]
  },
  {
    "objectID": "importing_data.html",
    "href": "importing_data.html",
    "title": "3  Importing Data",
    "section": "",
    "text": "3.1 Local Reading\nSo far, we have only made use of data which is pre-loaded into R via packages, but it is also possible to load your own data in from a variety of sources. We will focus on two different file types;\nAs described in Chapter 1, the bottom right pane of RStudio allows you to view files that are within your own personal filesystem. You are free to create new folders in this area, using the New Folder button.\nGreat, we will come back to using these two files, but first let’s discuss how to read in csv files.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Importing Data</span>"
    ]
  },
  {
    "objectID": "importing_data.html#local-reading",
    "href": "importing_data.html#local-reading",
    "title": "3  Importing Data",
    "section": "",
    "text": "−+ 05:00 \n\nNavigate to the Files at the bottom right pane of your RStudio\nCreate a new folder called data\nSave the GCP dataset to this folder as gcp.csv",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Importing Data</span>"
    ]
  },
  {
    "objectID": "importing_data.html#csv",
    "href": "importing_data.html#csv",
    "title": "3  Importing Data",
    "section": "3.2 CSV",
    "text": "3.2 CSV\nAlthough there is a read.csv() function in base R, like most things there is a better tidyverse alternative! read_csv() from the readr package reads CSVs in as a tibble (which has additional features compared to a standard data frame), is much faster (~10X), and allows you to specify how you read data in more easily.\nAs always, let’s read the function documentation using ?read_csv. This tells us we need to provide a path to the file. This path can be either local or remote; so it will work equally well for data inside your project or from the internet.\nTo read in a local file, you have to specify the exact location of the file. You can do this as either an absolute filepath, which starts from the drive name right through to the final file (e.g. C:/Documents/My_work/file.csv), or as a relative file path. A relative file path just gives the location of the file starting from your current working environment. You can check what your current working environment is using the command getwd(). The advantage of using relative file paths is if someone duplicates your project from Github, the code will still work on their own computer.\nWe will start by reading in some local data, which contains details of Kenyan Gross County Product by economic activity for 2017:\n\ngcp &lt;- read_csv(\"data/gcp.csv\")\n\nNotice that the file is inside the data folder inside the current working directory.\ngcp will now show in your environment. The environment viewer (top right) shows you basic information about the data that has been loaded in. You can also click on any object to view it in your script window.\nYou can also read in data directly from the web using the same function. For example, reading in this CSV of Eurovision Song Contest data:\n\neurovision_data &lt;- read_csv(\"https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2022/2022-05-17/eurovision.csv\")\n\nRows: 2005 Columns: 18\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (12): event, host_city, host_country, event_url, section, artist, song, ...\ndbl  (4): year, running_order, total_points, rank\nlgl  (2): qualified, winner\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nThis works exactly the same way as reading in local data, and the object you have created will appear in your environment (top right).\n\n3.2.1 Exercise\n −+ 05:00 \n\nRead in the frogs dataset found here:‘https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2022/2022-08-02/frogs.csv’ as an object called frogs\n\n\n\n4.2.1. Solution\n\n\n\nfrogs &lt;- read.csv(\"https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2022/2022-08-02/frogs.csv\")\n\n\n\n\n\n3.2.2 Inspecting the dataset\nAs noted in the previous section, you can see by looking in the environment window that the eurovision dataset has 2005 observations and 18 variables. You can also return this information (and more) about datasets programatically, using the glimpse() function, again from the dplyr package:\n\nglimpse(eurovision_data)\n\nRows: 2,005\nColumns: 18\n$ event          &lt;chr&gt; \"Turin 2022\", \"Turin 2022\", \"Turin 2022\", \"Turin 2022\",…\n$ host_city      &lt;chr&gt; \"Turin\", \"Turin\", \"Turin\", \"Turin\", \"Turin\", \"Turin\", \"…\n$ year           &lt;dbl&gt; 2022, 2022, 2022, 2022, 2022, 2022, 2022, 2022, 2022, 2…\n$ host_country   &lt;chr&gt; \"Italy\", \"Italy\", \"Italy\", \"Italy\", \"Italy\", \"Italy\", \"…\n$ event_url      &lt;chr&gt; \"https://eurovision.tv/event/turin-2022\", \"https://euro…\n$ section        &lt;chr&gt; \"first-semi-final\", \"first-semi-final\", \"first-semi-fin…\n$ artist         &lt;chr&gt; \"Kalush Orchestra\", \"S10\", \"Amanda Georgiadi Tenfjord\",…\n$ song           &lt;chr&gt; \"Stefania\", \"De Diepte\", \"Die Together\", \"Saudade, Saud…\n$ artist_url     &lt;chr&gt; \"https://eurovision.tv/participant/kalush-orchestra-22\"…\n$ image_url      &lt;chr&gt; \"https://static.eurovision.tv/hb-cgi/images/963164d0-06…\n$ artist_country &lt;chr&gt; \"Ukraine\", \"Netherlands\", \"Greece\", \"Portugal\", \"Bulgar…\n$ country_emoji  &lt;chr&gt; \":flag_ua:\", \":flag_nl:\", \":flag_gr:\", \":flag_pt:\", \":f…\n$ running_order  &lt;dbl&gt; 6, 8, 15, 10, 7, 5, 17, 16, 3, 9, 4, 14, 11, 1, 12, 2, …\n$ total_points   &lt;dbl&gt; 337, 221, 211, 208, 29, 15, 187, 177, 159, 154, 118, 10…\n$ rank           &lt;dbl&gt; 1, 2, 3, 4, 16, 17, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, …\n$ rank_ordinal   &lt;chr&gt; \"1st\", \"2nd\", \"3rd\", \"4th\", \"16th\", \"17th\", \"5th\", \"6th…\n$ qualified      &lt;lgl&gt; TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, TRUE, TRUE, TRUE,…\n$ winner         &lt;lgl&gt; FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,…\n\n\nAs well as returning the number of rows and columns in the data, the glimpse function also shows you the names of the columns, the column classes (indicated in ), and an example of the first few rows of data.\n\n\n3.2.3 Exercise\n −+ 05:00 \n\nUse the glimpse and View functions to examine the frogs dataset. How many rows and columns does it have?\n\n\n\n4.2.3. Solution\n\n\n\nView(frogs)\n\n\nglimpse(frogs)\n\nRows: 311\nColumns: 16\n$ Site       &lt;chr&gt; \"Crane Prairie\", \"Crane Prairie\", \"Crane Prairie\", \"Crane P…\n$ Subsite    &lt;chr&gt; \"SE Pond\", \"SE Pond\", \"SE Pond\", \"SE Pond\", \"SE Pond\", \"SE …\n$ HabType    &lt;chr&gt; \"Pond\", \"Pond\", \"Pond\", \"Pond\", \"Pond\", \"Pond\", \"Pond\", \"Po…\n$ SurveyDate &lt;chr&gt; \"9/25/2018\", \"10/2/2018\", \"10/9/2018\", \"10/15/2018\", \"10/22…\n$ Ordinal    &lt;int&gt; 268, 275, 282, 288, 295, 305, 309, 317, 322, 330, 270, 277,…\n$ Frequency  &lt;dbl&gt; 164.169, 164.169, 164.169, 164.169, 164.169, 164.169, 164.1…\n$ UTME_83    &lt;int&gt; 597369, 597352, 597345, 597340, 597344, 597410, 597369, 597…\n$ UTMN_83    &lt;int&gt; 4846486, 4846487, 4846458, 4846464, 4846460, 4846451, 48464…\n$ Interval   &lt;int&gt; 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,…\n$ Female     &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ Water      &lt;chr&gt; \"Deep water\", \"Deep water\", \"Shallow water\", \"Deep water\", …\n$ Type       &lt;chr&gt; \"Marsh/Pond\", \"Marsh/Pond\", \"Marsh/Pond\", \"Marsh/Pond\", \"Ma…\n$ Structure  &lt;chr&gt; \"Herbaceous veg\", \"Open\", \"Herbaceous veg\", \"Woody debris\",…\n$ Substrate  &lt;chr&gt; \"Unknown substrate\", \"Unknown substrate\", \"Unknown substrat…\n$ Beaver     &lt;chr&gt; \"No beaver\", \"No beaver\", \"No beaver\", \"No beaver\", \"No bea…\n$ Detection  &lt;chr&gt; \"Captured\", \"No visual\", \"No visual\", \"No visual\", \"No visu…",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Importing Data</span>"
    ]
  },
  {
    "objectID": "importing_data.html#excel",
    "href": "importing_data.html#excel",
    "title": "3  Importing Data",
    "section": "3.3 Excel",
    "text": "3.3 Excel\nReading excel files works in much the same way as CSV files. However, due to the difference in underlying structures we require the function read_excel() from a different package called readxl.\nThe main difference when reading excel files is three additional arguments that we can set;\n\nsheet which allows us to specify which sheet to read. It can take the form of a string (the name of the sheet) or an integer (the position of the sheet); and\nrange which allows us to specify a cell range. It takes a typical cell reference like “B3:D10”.\nskip an alternative to specifying a cell range, you can simply indicate how many rows to skip at the start of the sheet. This is ideal if you want to read in a sheet with an unknown number of columns and/or rows, but know there are several lines of metadata at the top of the sheet.\n\nIf we don’t set any of these arguments it will assume our data is in the first row of the first sheet (and it becomes almost identical to read_csv above).\n\n# One option is to download the file \nurl = \"https://www.knbs.or.ke/wp-content/uploads/2024/04/2023-Economic-Survey-Kenya-Tourism-Sector.xlsx\"\ndownload_first &lt;- download.file(,destfile = \"tourism.xlsx\")\ntourism &lt;- read_excel(\"tourism.xlsx\")\n\n\n3.3.1 Exercise\n −+ 10:00 \n\nInstall and load the readxl package.\nTry downloading an excel spreadsheet from KNBS. For example: “https://www.knbs.or.ke/wp-content/uploads/2024/04/2023-Economic-Survey-Kenya-Tourism-Sector.xlsx”\nSpecify the sheet name you want to read in.\nExamine the data you have read in; are the column names what you want? Work out how to skip these and only read in the data, with the correct column names.\n\n\n\n4.3.1. Solution\n\n\n\nurl = \"https://www.knbs.or.ke/wp-content/uploads/2024/04/2023-Economic-Survey-Kenya-Tourism-Sector.xlsx\"\ndownload_first &lt;- download.file(url,destfile = \"data/tourism.xlsx\")\ntourism &lt;- read_excel(\"data/tourism.xlsx\", sheet = \"Table 12.5\", skip = 2)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Importing Data</span>"
    ]
  },
  {
    "objectID": "importing_data.html#rio",
    "href": "importing_data.html#rio",
    "title": "3  Importing Data",
    "section": "3.4 Rio",
    "text": "3.4 Rio\nSometimes you may want to read a selection of files of all different types. This is where Rio can come in handy. Rio is a wrapper around the libraries we’ve used above and many more, which lets you use import() to read almost any file in. This isn’t always useful, when you want to do very specific things with a certain file, but can be much cleaner.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Importing Data</span>"
    ]
  },
  {
    "objectID": "ggplot.html",
    "href": "ggplot.html",
    "title": "4  Basic Plotting",
    "section": "",
    "text": "4.1 Structure\nThis chapter will teach you how to visualise your data using ggplot2. R has several systems for making graphs, but ggplot2 is the most elegant and versatile. The syntax behind ggplot2 looks complicated at first, but once you understand it, it’s incredibly powerful and can be used to visualise a wide range of data.\nThe main function in ggplot2 is ggplot() which is used to initialise a plot. A plot in ggplot2 is made up of multiple elements added to each other to create layers which each add something to the appearance of the chart. The basic template for a graph is as follows:\nggplot(data = &lt;DATA&gt;) +\n  &lt;GEOM_FUNCTION&gt;(mapping = aes(&lt;MAPPINGS&gt;))\nA geom function defines the way data and an aesthetic mapping is statistically transformed to create a plot. A plot can come in many forms, such as a bar graph, line and scatter graph, to name a few.\nA ggplot object must contain\nThis might look confusing initially, so let’s show an example with one of the pre-loaded R datasets mpg by creating a scatter plot of displacement against hwy.\n#Data to be plotted\nggplot(data = mpg, aes(x = displ, y = hwy))+\n  #The geometric to draw the aesthetics with (in this case a point geom)\n     #The aesthetic mapping; the x axis to displacement and the y to hmwy\n  geom_point()\nThis is the basic structure of any ggplot chart, but there are plenty of things you can do to change the appearance and function of your charts within ggplot.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Basic Plotting</span>"
    ]
  },
  {
    "objectID": "ggplot.html#structure",
    "href": "ggplot.html#structure",
    "title": "4  Basic Plotting",
    "section": "",
    "text": "the data to be plotted as the first argument\nhow that data should be mapped to the different aspects of the plot, defined using aes() (short for aesthetics).\na geometric to draw the aesthetics with\nggplot works with layers, each added with the + operator.\nMappings are always added using the aes() command, which can be inside the ggplot() or geom.\n\n\n\n\n\n4.1.1 Exercise\n −+ 10:00 \n\nUse the iris dataset (another built-in dataset in R) to create a simple scatter (geom_point) chart, plotting Sepal.Length as the x axis and Sepal.Width as the y\n\n\n\n3.1.1. Solution\n\n\n\nggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width)) +\n  geom_point()",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Basic Plotting</span>"
    ]
  },
  {
    "objectID": "ggplot.html#types-of-geom-functions",
    "href": "ggplot.html#types-of-geom-functions",
    "title": "4  Basic Plotting",
    "section": "4.2 Types of Geom Functions",
    "text": "4.2 Types of Geom Functions\nYou aren’t just limited to scatter plots; there are lots of geoms available in ggplot - the best resource for choosing an appropriate geom is the cheat sheet. This can be found at https://github.com/rstudio/cheatsheets/blob/main/data-visualization-2.1.pdf\nThe most commonly used geoms are:\n\n\n\nGeom Function\nDescription\n\n\n\n\ngeom_bar\nBar chart\n\n\ngeom_point\nScatter chart\n\n\ngeom_line\nLine graph\n\n\ngeom_histogram\nHistogram\n\n\ngeom_boxplot\nBox and whisker plot\n\n\ngeom_smooth\nLine of best fit style overlay\n\n\n\nYou can also add multiple geoms to a single plot, for example you can add a smoothed line to the scatter plot you have already created using geom_smooth. You can either define the aes in each of the geom calls if they are different for each layer, or define them in the initial ggplot call if they are consistent across all layers.\n\n#Aes defined in ggplot calll\nggplot(data = mpg, aes(x = displ, y = hwy))+\n  geom_point() + #Add a + sign\n  geom_smooth()#Include a smoothed line\n\n\n\n\n\n\n\n\n\n4.2.1 Exercise\n −+ 05:00 \n\nUse the geom_smooth aesthetic to add a smoothed line to your scatter plot.\n\n\n\n3.2.1. Solution\n\n\n\nggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width)) +\n  geom_point() +\n  geom_smooth()",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Basic Plotting</span>"
    ]
  },
  {
    "objectID": "ggplot.html#adding-different-aesthetics",
    "href": "ggplot.html#adding-different-aesthetics",
    "title": "4  Basic Plotting",
    "section": "4.3 Adding different aesthetics",
    "text": "4.3 Adding different aesthetics\nIt’s normal that you will want to explore more than two variables within your datasets. You can do this by mapping those variables to different aspects of the chart in ggplot; things like colour, point shape, or line type.\nFor example, we could set the colour of the point to be determined by the vehicle class.\n\n# Aesthetics\nggplot(data = mpg, aes(x = displ, y = hwy, colour = class))+\n  geom_point()\n\n\n\n\n\n\n\n\n\nggplot does some clever things when deciding what colours to use - for factorial variables it will assign each factor a unique colour (as in the above example), whilst for continuous variables it will assign a colour scale.\n\n# Here year is coloured as a continuous variable with a colour scale\nggplot(data = mpg, aes(x = displ, y = hwy, colour = year))+\n  geom_point()\n\n\n\n\n\n\n\n# Here by setting year to a factor it is coloured as a discrete variable with a unique colour for each\nggplot(data = mpg, aes(x = displ, y = hwy, colour = factor(year)))+\n  geom_point()\n\n\n\n\n\n\n\n\nThere are a wide range of other aesthetics you can set to indicate different categories including:\n\nPoint shape (shape)\nLine type (linetype)\nSize of points (size)\nTransparancy of points (alpha)\n\nApplying multiple aesthetics should be used with caution though; indicating more than one variable using aesthetics can quickly make a chart difficult to read!\n\n# A chart wit multiple aesthetics applied.\nggplot(data = mpg, aes(x = displ, y = hwy, colour = class, size = cty))+\n  geom_point(shape = 5)\n\n\n\n\n\n\n\n\nYou also don’t have to map aesthetics onto variables; you can specify them manually if you don’t want them to be related to a variable. To do this, you need to specify the colour, shape, linetype, etc outside of the aesthetic call. For example, you can define the colour of the points:\n\n#Aesthetics related to variables are mapped inside the aes call\nggplot(data = mpg, aes(x = displ, y = hwy))+\n  #Aesthetics that are manually set are mapped outside the aes call\n  geom_point(colour = \"orange\")\n\n\n\n\n\n\n\n\n\n4.3.1 Exercise\n −+ 10:00 \n\nMap the colour aesthetic of your chart to correspond to the Species in the iris dataset.\nManually map the shape of the geom_point to be type 3\n\n\n\n3.3.1. Solution\n\n\n\nggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width, colour = Species)) +\n  geom_point(shape = 3)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Basic Plotting</span>"
    ]
  },
  {
    "objectID": "ggplot.html#adding-layers",
    "href": "ggplot.html#adding-layers",
    "title": "4  Basic Plotting",
    "section": "4.4 Adding Layers",
    "text": "4.4 Adding Layers\nThis produces the basics of any ggplot2 chart, however it doesn’t always make the most attractive chart. To improve the appearance of the chart, the ggplot2 package has a wide range of functions which can be added to your basic chart to change everything from the legend, titles, or scales shown in the chart.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Basic Plotting</span>"
    ]
  },
  {
    "objectID": "ggplot.html#scales",
    "href": "ggplot.html#scales",
    "title": "4  Basic Plotting",
    "section": "4.5 Scales",
    "text": "4.5 Scales\nChanging the x and y axes can be done using the scale_x_ and scale_y_ group of functions. There is a different type of these functions for each different type of scale and axis, and you need to take care you use the right one in each case!\n\n##For a continuous Y axis\nggplot(data, aes(x = x_axis, y = y_axis))+\n  scale_y_continuous()\n\n##For dates on the X axis\nggplot(data, aes(x = x_axis, y = y_axis))+\n  scale_x_date()\n\nAn example of using a percent scale:\n\n# Scales \nggplot(data = mpg1, aes(x = displ, y = gallon_percent, colour = class))+\n  geom_point()+\n  #Set name for axis\n  scale_y_continuous(labels = scales::label_percent())\n\n\n\n\n\n\n\n\nYou can change a large number of aspects of both the appearance and function of the axes using these functions, including:\n\nName on the axis\nChange the minimum and maximum values on the scale\nSet major and minor values on the scale\nPosition of the axis\nType-specific changes such as setting the appearance of dates or transforming to log scale\n\n\n# Aesthetics\nggplot(data = mpg, aes(x = displ, y = hwy, colour = class))+\n  geom_point()+\n  #Set name for axis\n  scale_x_continuous(name = \"displacement\",\n                     #Set min and max limits\n                     limits = c(0,8))\n\n\n\n\n\n\n\n\nCheck the arguments available for any scale function using ? in front of it in the console; e.g. ?scale_x_date",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Basic Plotting</span>"
    ]
  },
  {
    "objectID": "ggplot.html#changing-colour-palettes",
    "href": "ggplot.html#changing-colour-palettes",
    "title": "4  Basic Plotting",
    "section": "4.6 Changing colour palettes",
    "text": "4.6 Changing colour palettes\nIf you don’t specify colours to use, ggplot will default to the (relatively ugly) standard palette. Luckily, there are loads of ways to easily choose more attractive colour options!\nNote that when you are changing colours in a chart, there are two different options; colour is used for points and lines in charts, while fill is for the central fill colour in objects like bars. Make sure you use the right one when calling scale arguments!\nUsing scale_colour_brewer() or scale_fill_brewer() allows you to select from one of the ColorBrewer palettes; these are designed to be attractive, and many of them are colour-blind friendly.\n\n#Chart using the standard colour brewer palette\n\nggplot(data = mpg, aes(x = displ, y = hwy, colour = class))+\n  geom_point()+\n  scale_colour_brewer()\n\n\n\n\n\n\n\n\nChange the palette used with the palette argument:\n\n#Chart using the Dark2 palette\n\nggplot(data = mpg, aes(x = displ, y = hwy, colour = class))+\n  geom_point()+\n  scale_colour_brewer(palette = \"Dark2\")\n\n\n\n\n\n\n\n\nYou can see the full range of palettes available with their names here:\n\n\n\n\n\n\n\n\n\nYou can also design your own custom palettes using either named colours or hex codes and pass them to your charts using the scale_*x*_manual functions:\n\n#Chart using a custom defined palette\n\nmy_cols &lt;- c(\"#DAF7A6\", \"#CCDC6D\", \"#FFC300\", \"#FF5733\", \"#C70039\", \"#900C3F\", \"#581845\")\n\nggplot(data = mpg, aes(x = displ, y = hwy, colour = class))+\n  geom_point()+\n  scale_colour_manual(values = my_cols)\n\n\n\n\n\n\n\n\n\n4.6.1 Exercise\n −+ 10:00 \n\nChange the colour palette your chart uses to something you like better than the default! Use the scale_colour_brewer or scale_colour_manual to do this.\n\n\n\n3.6.1. Solution\n\n\n\nggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width, colour = Species)) +\n  geom_point(shape = 3) +\n  scale_colour_brewer(palette = \"Dark2\")",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Basic Plotting</span>"
    ]
  },
  {
    "objectID": "ggplot.html#facets",
    "href": "ggplot.html#facets",
    "title": "4  Basic Plotting",
    "section": "4.7 Facets",
    "text": "4.7 Facets\nFaceting charts in R is a good way to produce multiple identical charts; this feature splits data by a provided variable and plots one value per chart. It is very useful when overlapping data is difficult to read. Using the facet_wrap() function, you can pass any variable to the first argument (prefacing it with ~), as well as specifying the row/column layout of the result\n\n#Chart using the Dark2 palette\n\nggplot(data = mpg, aes(x = displ, y = hwy, colour = class))+\n  geom_point()+\n  #Facet by class\n  facet_wrap(~class)+\n  scale_colour_brewer(palette = \"Dark2\")",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Basic Plotting</span>"
    ]
  },
  {
    "objectID": "ggplot.html#titles",
    "href": "ggplot.html#titles",
    "title": "4  Basic Plotting",
    "section": "4.8 Titles",
    "text": "4.8 Titles\nLabels and titles can be added without changing the axes using the labs command.\n\n#Themes, titles, and multiple plots\nggplot(data = mpg, aes(x = class, y =..prop.., group = 1))+\n  geom_bar()+\n  labs(title = \"Proportion of sample by class\", x = \"Class\", y = \"Proportion\")",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Basic Plotting</span>"
    ]
  },
  {
    "objectID": "ggplot.html#adding-themes",
    "href": "ggplot.html#adding-themes",
    "title": "4  Basic Plotting",
    "section": "4.9 Adding themes",
    "text": "4.9 Adding themes\nChanging the theme is a quick and easy way to set many of the visual aspects of your charts, such as the appearance of grid lines, size of text, and position of the legends. You can change the theme to a number of presets:\n\n\nplot &lt;- ggplot(data = mpg, aes(x = displ, y = hwy, colour = class))+\n  geom_point()+\n  scale_colour_brewer(palette = \"Dark2\")\n\n#Applying different themes\n plot+theme_bw() \n\n\n\n\n\n\n\n plot+theme_classic() \n\n\n\n\n\n\n\n plot+theme_minimal()\n\n\n\n\n\n\n\n plot+theme_light()\n\n\n\n\n\n\n\n\n\nYou can also make your own custom themes; plot are made up of four elements element_text, element_line, element_rect, and element_blank. Plots can be modified using these element commands. For example:\n\n#You can also make your own custom themes\n#\nugly.theme &lt;-\n  theme(\n    text = element_text(colour ='orange', face ='bold'),\n    panel.grid.major = element_line(colour = \"violet\", linetype = \"dashed\"),\n    panel.grid.minor = element_blank(),\n    panel.background = element_rect(fill = 'black', colour = 'red')\n  )\n\n\n\nplot+ugly.theme\n\n\n\n\n\n\n\n\n\n4.9.1 Exercise\n −+ 10:00 \n\nAdd one of the default themes to your chart to improve its appearance.\nAdd a title and labels to your axes\n\n\n\n3.9.1. Solution\n\n\n\nggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width, colour = Species)) +\n  geom_point() +\n  #Add title and labels to axes\n  labs(title = \"Chart\", x = \"Sepal.Length\", y = \"Sepal.Width\") +\n  scale_colour_brewer(palette = \"Dark2\") +\n  #Add in-built R theme\n  theme_bw()",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Basic Plotting</span>"
    ]
  },
  {
    "objectID": "ggplot.html#saving-plots",
    "href": "ggplot.html#saving-plots",
    "title": "4  Basic Plotting",
    "section": "4.10 Saving plots",
    "text": "4.10 Saving plots\nMost of the time you will want to create plots directly into an R Markdown output, or a shiny app. However plots can also be saved as image (png) file:\n\n‘Export’ button in RStudio viewer\nggsave(filename = “plotname.png”, plot = myplot) - saves the plot into your current working directory in R Studio. Can then be downloaded from the platform via ‘More’ -&gt; ‘Export…’\n\n\n4.10.1 Saving a plot with today’s date\nSomething that has been raised in this section is: what if I want to add today’s date in the filename when saving a plot? This can be useful for organising and tracking plots over time. To do this, you can use the Sys.Date() function in R, which returns the current date in YYYY-MM-DD format.\nFor example, if you wanted to save a plot with today’s date included in the filename, you could use:\n\nggsave(filename = paste0(\"plot_\", Sys.Date(), \".png\"), plot = myplot)\n\nThis will save the plot myplot as a PNG file with a filename that includes the current date, like plot_2025-03-07.png, where Sys.Date() provides today’s date in the format YYYY-MM-DD. It’s a great way to ensure your plot files are uniquely named based on the date.\n\nThis is a good opportunity to take a 10-minute break away from the computer to refresh your mind, stretch, and reset before continuing onto Chapter 4 and 5.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Basic Plotting</span>"
    ]
  }
]