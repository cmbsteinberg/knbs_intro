{
  "hash": "f007fba2283ef740573b240ce5c221d1",
  "result": {
    "engine": "knitr",
    "markdown": "# Data Manipulation\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn this chapter, we will cover `dplyr`, one of the most essential packages in an R user's toolkit. As a key part of the `tidyverse`, `dplyr` offers easy-to-use functions for manipulating data frames, which is a vital step in the data analysis process.\n\nTo illustrate the key functions of `dplyr`, we'll be using the `gapminder` dataset. You can view this dataset by installing and loading the `gapminder` package, just as you did with tidyverse.\n\nThe exercises in this chapter will use an inbuilt R dataset. However, if you'd like to follow along with the examples, you're welcome to load the `gapminder` dataset, although please note it will not be required for the exercises themselves.\n\n<br>\n\nThere are six key `dplyr` functions that allow you to solve the vast majority of data-manipulation challenges;\n\n-   `select()` to pick variables/columns by their names.\n-   `group_by()` to change the scope of each function from operating on the entire data set to operating on it group-by-group.\n-   `summarise()` to collapse many values down to a single summary.\n-   `filter()` to pick observations by their value.\n-   `mutate()` to create new variables/columns with functions of existing variables/columns.\n-   `arrange()` to reorder the rows.\n\nThese functions look similar to SQL statements and are designed to replace the need for any data manipulation in SQL.\n\nAll `dplyr` functions allow you to specify the column names without \"quotations\". However, if there are spaces in the column name, you'll need to use `` `back ticks` ``.\n\n## Select\n\nSelect allows you to choose the columns that you'd like to keep from a dataset.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?select\n```\n:::\n\n\n\n\n\n\n\n\nLooking at the gapminder dataset, if we want to create a new dataset which only included the year, country and life expectancy, we could do this by selecting those columns:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder_life_exp <- select(gapminder, year, country, lifeExp)\n```\n:::\n\n\n\n\n\n\n\n\nThe first argument within the select command specifies use of the gapminder dataset. Following this we list the variables we want to keep.\n\nIt is also possible to select to *exclude* specific columns. This is ideal if you want to keep all columns except for one or two, and can be done by using a `-` minus sign in front of column names.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Removes the continent column but keeps all others\ngapminder_no_continent <- select(gapminder, -continent)\n```\n:::\n\n\n\n\n\n\n\n\nYou can also use the `select` function to reorder columns as it will select columns in the order specified.\n\n### Exercise\n\n`<div class=\"countdown\" id=\"timer_d55d12b9\" data-update-every=\"1\" tabindex=\"0\" style=\"right:0;bottom:0;position: relative; width: min-content;\">\n<div class=\"countdown-controls\"><button class=\"countdown-bump-down\">&minus;</button><button class=\"countdown-bump-up\">&plus;</button></div>\n<code class=\"countdown-time\"><span class=\"countdown-digits minutes\">10</span><span class=\"countdown-digits colon\">:</span><span class=\"countdown-digits seconds\">00</span></code>\n</div>`{=html}\n\n1.  Using the inbuilt dataset `airquality`, select to keep the columns Ozone, Temp, Month and Day.\n\n<details>\n\n<summary style=\"font-size: 20px; font-weight: bold;\">\n\n2.1.1. Solution</strong>\n\n</summary>\n\n<br>\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nairquality_exercise <-\n  select(airquality, Ozone, Temp, Month, Day)\n```\n:::\n\n\n\n\n\n\n\n\n</details>\n\n<br>\n\n## Pipes\n\nBefore we continue, let's visit one of the most important (and cool) operators in R... the pipe `|>`. You may have seen the old pipe `%>%` before. This has been replaced with a native pipe in R 4.1 onwards. It's likely that you'll want to use multiple functions consecutively, especially when using `dplyr`. Currently, we may do something like this:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder_new <- select(gapminder, -continent)\ngapminder_new <- select(gapminder_new, year, country, lifeExp)\n```\n:::\n\n\n\n\n\n\n\n\nThis code is a little frustrating to write because we have to name each intermediate data frame, even though we don't care about it. Naming things is hard, and having separate names for each step makes it difficult to read. Let's see how we can rewrite this code using the pipe:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder_new <- gapminder |>\n select(-continent) |> \n select(year, country, lifeExp)\n```\n:::\n\n\n\n\n\n\n\n\nThe pipe means we can read this code as a series of statements separated by the pipe representing \"and then\"; e.g. take the gapminder data *and then* remove the continent column *and then* select the year, country and lifeExp columns.\n\nYou may notice that we don't need to specify the `data` argument in each function when using \\|\\>. By piping, the subsequent function recognises we want to use the result of our previous statement as our data.\n\nYou can quickly insert the pipe operator in RStudio by pressing `Ctrl` + `Shift` + `M` (Windows) or `Cmd` + `Shift` + `M` (Mac). This will still insert the old pipe `%>%`. This can be changed in `Tools` \\> `Global Options` \\> `Code` \\> `Editing` \\> `Use native pipe operator, |>`\n\n## Grouping and summarising data\n\nWe can produce breakdowns of statistics using the group_by and summarise commands from the dplyr package:\n\n-   group_by() identifies which variables we want to produce breakdowns by.\n-   summarise() is used to indicate which values we want to calculate.\n\nUsing these functions together we can produce summary statistics in a similar way to pivot tables in Excel. We can use the pipe (\\|\\>) operator to chain these functions together.\n\nSo if we want the mean life expectancy by *continent* and *year*:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean_life_exp <- gapminder |>\n  group_by(year, continent) |>\n  summarise(life_exp = mean(lifeExp))\n```\n:::\n\n\n\n\n\n\n\n\nHere R takes the dataset, then groups it first by year and then by continent and then outputs the mean life expectancy. The mean life expentancy variable is created as a new column called `life_exp`. The results are saved into a new dataset called `mean_life_exp`.\n\nThere are other functions that could be used here instead of mean e.g. n, n_distinct, min, max, mean, median, var and sd.\n\nIf we want to add a new variable that we decide to call `country_count` that provides the counts by year and continent we can rerun as follows using the pipe operator:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean_life_exp <- gapminder |>\n  group_by(year, continent) |>\n  summarise(life_exp = mean(lifeExp), country_count = n())\n```\n:::\n\n\n\n\n\n\n\n\n### Exercise\n\n`<div class=\"countdown\" id=\"timer_9bf1a10a\" data-update-every=\"1\" tabindex=\"0\" style=\"right:0;bottom:0;position: relative; width: min-content;\">\n<div class=\"countdown-controls\"><button class=\"countdown-bump-down\">&minus;</button><button class=\"countdown-bump-up\">&plus;</button></div>\n<code class=\"countdown-time\"><span class=\"countdown-digits minutes\">10</span><span class=\"countdown-digits colon\">:</span><span class=\"countdown-digits seconds\">00</span></code>\n</div>`{=html}\n\n1.  Using the pipe function, group the airquality dataset by month.\n2.  Summarise the grouped dataset to produce an average of Ozone and Temp by month.\n3.  Assign this to an object called airquality_summarised.\n\n<details>\n\n<summary style=\"font-size: 20px; font-weight: bold;\">\n\n2.3.1. Solution</strong>\n\n</summary>\n\n<br>\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nairquality_summarised <- airquality |>\n  group_by(Month) |>\n  summarise(avg_ozone = mean(Ozone, na.rm = TRUE),\n            avg_temp = mean(Temp, na.rm = TRUE))\n```\n:::\n\n\n\n\n\n\n\n\n</details>\n\n<br>\n\n## Filter\n\nIf you would like to produce statistics for a subset of rows or observations, a good function to use is filter() from the dplyr package.\n\nLet's first take a look at the different possible values of the continent variable. We can do that quickly using the group_by/summarise combination.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |>\n  group_by(continent) |>\n  summarise(count = n())\n```\n:::\n\n\n\n\n\n\n\n\nTo filter we just specify the data that we want to filter (gapminder) and the value that we want to filter on. In this case lets filter where continent is \"Asia\" and year is after 1992 then recalculate the mean life expectancy by country:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean_life_exp <- gapminder |> \nfilter(continent == \"Asia\" & year > 1992) |>\ngroup_by(country) |>\nsummarise(life_exp = mean(lifeExp))\n```\n:::\n\n\n\n\n\n\n\n\nR provides the standard suite of comparison operators which can be used to filter:\n\n| Comparison               | Operator |\n|--------------------------|----------|\n| Greater than             | \\>       |\n| Greater than or equal to | \\>=      |\n| Less than                | \\<       |\n| Less than or equal to    | \\<=      |\n| Equal to                 | ==       |\n| Not equal to             | !=       |\n| And                      | &        |\n| Or                       | \\|       |\n| Not                      | !        |\n| Group membership         | %in%     |\n\nThe `%in%` operator allows you to compare a column against a vector of values to see if it matches any one of them; this is much more convenient than comparing against each value individually.\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n##This does work to filter the data for the three given years but is clunky to read and edit\ngapminder |> \nfilter(year == 1992 | year == 1998 | year == 2002) \n\n##Using the %in% operator is simple and clean to read, and gives exactly the same result\ngapminder |> \nfilter(year %in% c(1992, 1998, 2002)) \n```\n:::\n\n\n\n\n\n\n\n\n### Exercise\n\n`<div class=\"countdown\" id=\"timer_8df02805\" data-update-every=\"1\" tabindex=\"0\" style=\"right:0;bottom:0;position: relative; width: min-content;\">\n<div class=\"countdown-controls\"><button class=\"countdown-bump-down\">&minus;</button><button class=\"countdown-bump-up\">&plus;</button></div>\n<code class=\"countdown-time\"><span class=\"countdown-digits minutes\">05</span><span class=\"countdown-digits colon\">:</span><span class=\"countdown-digits seconds\">00</span></code>\n</div>`{=html}\n\n1.  Filter the original airquality dataset to only include data for May and June. Try to do this using the %in% function.\n2.  Call this assignment: airquality_filter.\n\n<details>\n\n<summary style=\"font-size: 20px; font-weight: bold;\">\n\n2.4.1. Solution</strong>\n\n</summary>\n\n<br>\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nairquality_filter <- airquality |>\n  filter(Month %in% c(5, 6))\n```\n:::\n\n\n\n\n\n\n\n\n</details>\n\n<br>\n\n## Rename\n\nWe can rename variables using the dplyr function rename(). Let’s amend our previous code creating the mean_life_exp dataset to change the name of the \"year\" column to \"selected_year\".\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean_life_exp <- gapminder |> \n  filter(continent == \"Asia\" & year > 1992) |>\n  group_by(year, country) |>\n  summarise(life_exp = mean(lifeExp)) |>\n  rename(selected_year = year)\n```\n:::\n\n\n\n\n\n\n\n\nWithin the rename function, the new name \"selected_year\" is specified on the left and the old name on the right of the equal sign.\n\n## Mutate\n\nYou can create new columns and perform calculations on existing columns using the dplyr command mutate().\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?mutate\n```\n:::\n\n\n\n\n\n\n\n\nFor example, imagine we wanted to calculate overall GDP as a new column in the gapminder dataset. We could do this by multiplying the `gdpPercap` and `pop` columns:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |>\n  mutate(gdp_total = gdpPercap * pop)\n```\n:::\n\n\n\n\n\n\n\n\nYou can also use functions like `mean()` and `sum()` in `mutate()`. For example, using `x / sum(x)` for calculating proportions of a total and `y - mean(y)` for difference from the mean.\n\nNotice that by default, mutate calculates values on a *rowwise* basis; each value in the gdp_total column is made by multiplying the values in the corresponding row. This default behaviour can be changed by grouping data before mutate, e.g. this code produces a mean population column by country:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |>\n group_by(country) |>\n mutate(mean_pop = mean(pop))\n```\n:::\n\n\n\n\n\n\n\n\nYou can also combine mutate with the `case_when` function to perform one or more if/else conditions. Maybe we want to have coded values for each year by decade. The case_when function allows you to provide multiple instances of a statement which evaluates to TRUE/FALSE, and then a result if that condition is true (after `~`). The function evaluates these statements in order, so if an earlier statement is TRUE, a later one will not be evaluated. Finally, for cases that don't meet any of the conditions, the final TRUE value is used (this defaults to NA if not specified)\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |>\n  mutate(\n    decade =\n      case_when(\n        year >= 1950 & year < 1960 ~ \"1950s\",\n        year >= 1960 & year < 1970 ~ \"1960s\",\n        year >= 1970 & year < 1980 ~ \"1970s\",\n        year >= 1980 & year < 1990 ~ \"1980s\",\n        year >= 1990 & year < 2000 ~ \"1990s\",\n        TRUE ~ \"Post-2000\"\n      )\n  )\n```\n:::\n\n\n\n\n\n\n\n\nYou can download the Data Transformation Cheat Sheet (and other cheatsheets) at: <https://www.rstudio.com/resources/cheatsheets/>\n\n### Exercise\n\n`<div class=\"countdown\" id=\"timer_63eaadee\" data-update-every=\"1\" tabindex=\"0\" style=\"right:0;bottom:0;position: relative; width: min-content;\">\n<div class=\"countdown-controls\"><button class=\"countdown-bump-down\">&minus;</button><button class=\"countdown-bump-up\">&plus;</button></div>\n<code class=\"countdown-time\"><span class=\"countdown-digits minutes\">10</span><span class=\"countdown-digits colon\">:</span><span class=\"countdown-digits seconds\">00</span></code>\n</div>`{=html}\n\n1.  The inbuilt trees dataset includes columns for tree girth and height in inches. Using mutate, create two new columns (Girth_cm and Height_cm) containing the equivalent values in centimetres.\n2.  How can you replace an existing column with a new column using mutate?\n\n<details>\n\n<summary style=\"font-size: 20px; font-weight: bold;\">\n\n2.6.1. Solution</strong>\n\n</summary>\n\n<br>\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1. conversion is 2.54\n\ntrees_with_cm <- trees |>\n  mutate(Girth_cm = Girth * 2.54,\n         Height_cm = Height * 2.54)\n\n# 2. Using mutate to replace existing column\n\ntrees_with_cm <- trees |>\n  mutate(Girth = Girth * 2.54)\n```\n:::\n\n\n\n\n\n\n\n\n</details>\n\n<br>\n\n## Arrange\n\n`arrange()` is used to change the order of rows. It takes a data frame as it's first argument and a column name to sort by as it's second. If you provide more than one column name, each additional column will be used to break ties in the values of preceding columns. By default `arrange()` will sort in ascending order (1-9 and A-Z). If you'd like to sort in descending order wrap the column name in `desc()`. Using arrange with one column sorts how you'd might expect:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |>\n arrange(year)\n```\n:::\n\n\n\n\n\n\n\n\nSorting with multiple columns sorts within the hierarchy specified:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder |>\n  arrange(year, desc(continent))\n```\n:::\n\n\n\n\n\n\n\n\nIt's worth noting that missing values (NA) are always sorted at the end:\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tibble(x = c(1, 2, 3, NA))\narrange(df, x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 1\n      x\n  <dbl>\n1     1\n2     2\n3     3\n4    NA\n```\n\n\n:::\n\n```{.r .cell-code}\narrange(df, desc(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 1\n      x\n  <dbl>\n1     3\n2     2\n3     1\n4    NA\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n### Exercise\n\n`<div class=\"countdown\" id=\"timer_4cf8536f\" data-update-every=\"1\" tabindex=\"0\" style=\"right:0;bottom:0;position: relative; width: min-content;\">\n<div class=\"countdown-controls\"><button class=\"countdown-bump-down\">&minus;</button><button class=\"countdown-bump-up\">&plus;</button></div>\n<code class=\"countdown-time\"><span class=\"countdown-digits minutes\">05</span><span class=\"countdown-digits colon\">:</span><span class=\"countdown-digits seconds\">00</span></code>\n</div>`{=html}\n\n1.  Arrange the rows of the `trees` dataset by increasing height and decreasing girth.\n2.  What do you notice?\n\n<details>\n\n<summary style=\"font-size: 20px; font-weight: bold;\">\n\n2.7.1. Solution</strong>\n\n</summary>\n\n<br>\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrees_arranged <- trees |>\n  arrange(Height, desc(Girth))\n```\n:::\n\n\n\n\n\n\n\n\n</details>\n\n<br>\n\nThis is a good opportunity to take a 45-minute to an hour lunch break away from the computer to refresh your mind, stretch, and reset before continuing onto Chapter 3.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"site_libs/countdown-0.4.0/countdown.css\" rel=\"stylesheet\" />\n<script src=\"site_libs/countdown-0.4.0/countdown.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}